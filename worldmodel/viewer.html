<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>World Model Demo Viewer</title>
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #14141f;
    --surface2: #1e1e2e;
    --border: #2a2a3e;
    --text: #e0e0e8;
    --text-dim: #8888a0;
    --p0: #4488ff;
    --p0-dim: rgba(68, 136, 255, 0.3);
    --p1: #ff4466;
    --p1-dim: rgba(255, 68, 102, 0.3);
    --correct: #44cc88;
    --wrong: #ff6644;
    --seed-color: #6644cc;
    --accent: #8866ff;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  /* --- Drop zone --- */
  #drop-zone {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    min-height: 100vh;
    gap: 20px;
    transition: background 0.2s;
  }

  #drop-zone.dragover {
    background: rgba(136, 102, 255, 0.08);
  }

  #drop-zone h1 {
    font-size: 28px;
    font-weight: 600;
    color: var(--accent);
  }

  #drop-zone p {
    color: var(--text-dim);
    font-size: 14px;
  }

  #drop-zone label {
    background: var(--surface2);
    border: 2px dashed var(--border);
    border-radius: 12px;
    padding: 40px 60px;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
    text-align: center;
  }

  #drop-zone label:hover {
    border-color: var(--accent);
    background: var(--surface);
  }

  #file-input { display: none; }

  /* --- Main viewer --- */
  #viewer {
    display: none;
    width: 100%;
    max-width: 1100px;
    padding: 16px;
    gap: 12px;
    flex-direction: column;
  }

  /* Header */
  #header {
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
    padding: 12px 16px;
    background: var(--surface);
    border-radius: 8px;
    border: 1px solid var(--border);
    font-size: 13px;
  }

  .header-tag {
    padding: 4px 10px;
    border-radius: 4px;
    background: var(--surface2);
    border: 1px solid var(--border);
    white-space: nowrap;
  }

  .header-tag.mode-tf { border-color: var(--correct); color: var(--correct); }
  .header-tag.mode-ar { border-color: var(--accent); color: var(--accent); }
  .header-tag.mode-agent { border-color: #ffaa22; color: #ffaa22; }

  /* Stage canvas */
  #stage-container {
    background: var(--surface);
    border-radius: 8px;
    border: 1px solid var(--border);
    padding: 12px;
    position: relative;
  }

  #stage-canvas {
    width: 100%;
    display: block;
    border-radius: 4px;
  }

  #legend {
    position: absolute;
    top: 16px;
    right: 16px;
    font-size: 11px;
    color: var(--text-dim);
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    display: inline-block;
  }

  /* Player info */
  #player-info {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
  }

  .player-card {
    background: var(--surface);
    border-radius: 8px;
    border: 1px solid var(--border);
    padding: 12px 16px;
    font-size: 13px;
  }

  .player-card.p0 { border-left: 3px solid var(--p0); }
  .player-card.p1 { border-left: 3px solid var(--p1); }

  .player-card h3 {
    font-size: 12px;
    color: var(--text-dim);
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .player-card .action-line {
    font-size: 14px;
    margin-bottom: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .player-card .stats-line {
    font-size: 12px;
    color: var(--text-dim);
  }

  .action-correct { color: var(--correct); }
  .action-wrong { color: var(--wrong); }

  .top3 {
    margin-top: 6px;
    font-size: 11px;
    color: var(--text-dim);
  }

  .top3 .prob-bar {
    display: inline-block;
    height: 8px;
    background: var(--accent);
    border-radius: 2px;
    margin-right: 4px;
    vertical-align: middle;
    opacity: 0.6;
  }

  /* Controls */
  #controls {
    background: var(--surface);
    border-radius: 8px;
    border: 1px solid var(--border);
    padding: 12px 16px;
  }

  #controls-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }

  #controls-row button {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: 4px;
    padding: 6px 10px;
    cursor: pointer;
    font-family: inherit;
    font-size: 13px;
    transition: background 0.15s;
  }

  #controls-row button:hover { background: var(--border); }
  #controls-row button.active { background: var(--accent); border-color: var(--accent); }

  #frame-display {
    font-size: 13px;
    color: var(--text-dim);
    margin-left: auto;
  }

  #speed-select {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: 4px;
    padding: 4px 8px;
    font-family: inherit;
    font-size: 12px;
    cursor: pointer;
  }

  /* Timeline */
  #timeline-container {
    position: relative;
    height: 28px;
    cursor: pointer;
  }

  #timeline-bg {
    position: absolute;
    top: 8px;
    left: 0;
    right: 0;
    height: 12px;
    background: var(--surface2);
    border-radius: 6px;
    overflow: hidden;
  }

  #seed-region {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: var(--seed-color);
    opacity: 0.3;
  }

  #timeline-progress {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: var(--accent);
    opacity: 0.4;
    transition: width 0.05s linear;
  }

  #timeline-thumb {
    position: absolute;
    top: 4px;
    width: 4px;
    height: 20px;
    background: var(--text);
    border-radius: 2px;
    transform: translateX(-2px);
    transition: left 0.05s linear;
  }

  #timeline-labels {
    display: flex;
    justify-content: space-between;
    font-size: 10px;
    color: var(--text-dim);
    margin-top: 2px;
  }

  /* Heatmap overlay on timeline */
  #timeline-heatmap {
    position: absolute;
    top: 8px;
    left: 0;
    right: 0;
    height: 12px;
    border-radius: 6px;
    pointer-events: none;
    z-index: 1;
  }

  /* Live stats row */
  #live-stats {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    min-height: 28px;
  }

  .live-chip {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 4px 10px;
    font-size: 11px;
    white-space: nowrap;
  }

  .live-chip .lc-label {
    color: var(--text-dim);
    margin-right: 4px;
  }

  .live-chip .lc-val { font-weight: 600; }
  .live-chip .lc-val.good { color: var(--correct); }
  .live-chip .lc-val.warn { color: #ffaa44; }
  .live-chip .lc-val.bad { color: var(--wrong); }

  /* Stats */
  #stats-bar {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
  }

  .stat-chip {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 8px 14px;
    font-size: 13px;
    flex: 1;
    min-width: 120px;
    text-align: center;
  }

  .stat-chip .label {
    font-size: 10px;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
  }

  .stat-chip .value {
    font-size: 18px;
    font-weight: 600;
  }

  .stat-chip .value.good { color: var(--correct); }
  .stat-chip .value.warn { color: #ffaa44; }
  .stat-chip .value.bad { color: var(--wrong); }

  /* New file button */
  #new-file-btn {
    position: fixed;
    top: 12px;
    right: 12px;
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text-dim);
    border-radius: 4px;
    padding: 6px 12px;
    cursor: pointer;
    font-family: inherit;
    font-size: 12px;
    z-index: 10;
  }

  #new-file-btn:hover { color: var(--text); border-color: var(--accent); }

  /* Error log */
  #error-log-container {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
  }

  #error-log-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 16px;
    cursor: pointer;
    user-select: none;
    border-bottom: 1px solid var(--border);
  }

  #error-log-header:hover { background: var(--surface2); }

  #error-log-title {
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-dim);
  }

  #error-log-count {
    font-weight: 600;
    color: var(--wrong);
    margin-left: 8px;
  }

  #error-log-actions {
    display: flex;
    gap: 8px;
  }

  #error-log-actions button {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text-dim);
    border-radius: 4px;
    padding: 3px 10px;
    cursor: pointer;
    font-family: inherit;
    font-size: 11px;
  }

  #error-log-actions button:hover { color: var(--text); border-color: var(--accent); }

  #error-log-body {
    max-height: 400px;
    overflow-y: auto;
    display: none;
  }

  #error-log-body.open { display: block; }

  #error-log-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 11px;
  }

  #error-log-table th {
    position: sticky;
    top: 0;
    background: var(--surface2);
    color: var(--text-dim);
    text-align: left;
    padding: 6px 10px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-size: 10px;
  }

  #error-log-table td {
    padding: 4px 10px;
    border-top: 1px solid rgba(42, 42, 62, 0.5);
    white-space: nowrap;
  }

  #error-log-table tr:hover { background: var(--surface2); }

  #error-log-table tr.clickable { cursor: pointer; }

  .err-player { font-weight: 600; }
  .err-player.p0 { color: var(--p0); }
  .err-player.p1 { color: var(--p1); }

  .err-pos { color: var(--wrong); }
  .err-action-wrong { color: var(--wrong); }
  .err-action-right { color: var(--correct); }
</style>
</head>
<body>

<div id="drop-zone">
  <h1>World Model Demo Viewer</h1>
  <p>No Johns — Melee frame prediction visualization</p>
  <label for="file-input">
    <div style="font-size: 40px; margin-bottom: 12px;">&#128506;</div>
    <div>Drop a demo.json here or click to browse</div>
    <div style="margin-top: 8px; font-size: 12px; color: var(--text-dim);">
      Generated by <code>worldmodel.scripts.generate_demo</code>
    </div>
  </label>
  <input type="file" id="file-input" accept=".json">
</div>

<button id="new-file-btn" style="display:none;">Load new file</button>

<div id="viewer">
  <div id="header"></div>
  <div id="stage-container">
    <canvas id="stage-canvas" width="1060" height="520"></canvas>
    <div id="legend"></div>
  </div>
  <div id="player-info">
    <div class="player-card p0" id="p0-card"></div>
    <div class="player-card p1" id="p1-card"></div>
  </div>
  <div id="controls">
    <div id="controls-row">
      <button id="btn-rew" title="Rewind 10 frames">&#9198;</button>
      <button id="btn-back" title="Step back 1 frame">&#9664;</button>
      <button id="btn-play" title="Play/Pause" class="active">&#9654;</button>
      <button id="btn-fwd" title="Step forward 1 frame">&#9654;</button>
      <button id="btn-ffwd" title="Forward 10 frames">&#9197;</button>
      <select id="speed-select">
        <option value="0.25">0.25x</option>
        <option value="0.5">0.5x</option>
        <option value="1" selected>1x</option>
        <option value="2">2x</option>
        <option value="4">4x</option>
        <option value="10">10x</option>
      </select>
      <span id="frame-display">Frame 0/0</span>
    </div>
    <div id="timeline-container">
      <div id="timeline-bg">
        <div id="seed-region"></div>
        <div id="timeline-progress"></div>
      </div>
      <canvas id="timeline-heatmap"></canvas>
      <div id="timeline-thumb" style="z-index:2"></div>
    </div>
  </div>
  <div id="live-stats"></div>
  <div id="stats-bar"></div>
  <div id="error-log-container" style="display:none;">
    <div id="error-log-header" onclick="toggleErrorLog()">
      <span><span id="error-log-title">Prediction Errors</span><span id="error-log-count"></span></span>
      <div id="error-log-actions">
        <button onclick="event.stopPropagation(); copyErrorLog()">Copy</button>
        <span id="error-log-chevron">&#9660;</span>
      </div>
    </div>
    <div id="error-log-body">
      <table id="error-log-table">
        <thead><tr>
          <th>Frame</th><th>Player</th><th>Type</th>
          <th>Predicted</th><th>Actual</th><th>Pos Err</th>
        </tr></thead>
        <tbody id="error-log-tbody"></tbody>
      </table>
    </div>
  </div>
</div>

<script>
// ===== State =====
let demoData = null;
let currentFrame = 0;
let playing = false;
let playInterval = null;
let speed = 1;

// Precomputed cumulative arrays for O(1) running stats
let cumActionCorrect = null;  // [p0_correct, p1_correct] cumulative
let cumPosError = null;       // cumulative sum of position errors
let frameCount = 0;

// ===== File loading =====
const dropZone = document.getElementById('drop-zone');
const fileInput = document.getElementById('file-input');
const viewer = document.getElementById('viewer');
const newFileBtn = document.getElementById('new-file-btn');

dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  if (e.dataTransfer.files.length) loadFile(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', () => { if (fileInput.files.length) loadFile(fileInput.files[0]); });
newFileBtn.addEventListener('click', () => {
  viewer.style.display = 'none';
  newFileBtn.style.display = 'none';
  dropZone.style.display = 'flex';
  stop();
  demoData = null;
});

function loadFile(file) {
  const reader = new FileReader();
  reader.onload = () => {
    try {
      demoData = JSON.parse(reader.result);
      initViewer();
    } catch (e) {
      alert('Failed to parse JSON: ' + e.message);
    }
  };
  reader.readAsText(file);
}

// ===== Viewer init =====
function initViewer() {
  dropZone.style.display = 'none';
  viewer.style.display = 'flex';
  newFileBtn.style.display = 'block';
  currentFrame = 0;

  const m = demoData.meta;
  const modeClass = m.mode === 'teacher-forced' ? 'mode-tf'
    : m.mode === 'agent-vs-agent' ? 'mode-agent' : 'mode-ar';
  const modeLabel = m.mode === 'teacher-forced' ? 'Teacher-Forced'
    : m.mode === 'agent-vs-agent' ? 'Agent vs Agent' : 'Autoregressive';

  const agentTag = m.mode === 'agent-vs-agent'
    ? `<span class="header-tag">${m.p0_agent || '?'} vs ${m.p1_agent || '?'}</span>` : '';

  document.getElementById('header').innerHTML = `
    <span class="header-tag">${m.model_name}</span>
    <span class="header-tag">${m.arch.toUpperCase()}</span>
    <span class="header-tag">${m.stage.name}</span>
    <span class="header-tag">${m.characters.p0.name} vs ${m.characters.p1.name}</span>
    <span class="header-tag ${modeClass}">${modeLabel}</span>
    ${agentTag}
    <span class="header-tag">K=${m.context_len}</span>
  `;

  const isTF = m.mode === 'teacher-forced';
  document.getElementById('legend').innerHTML = isTF ? `
    <div class="legend-item"><span class="legend-dot" style="background:var(--p0)"></span> P0 actual</div>
    <div class="legend-item"><span class="legend-dot" style="background:var(--p0);opacity:0.4"></span> P0 predicted</div>
    <div class="legend-item"><span class="legend-dot" style="background:var(--p1)"></span> P1 actual</div>
    <div class="legend-item"><span class="legend-dot" style="background:var(--p1);opacity:0.4"></span> P1 predicted</div>
  ` : `
    <div class="legend-item"><span class="legend-dot" style="background:var(--p0)"></span> P0</div>
    <div class="legend-item"><span class="legend-dot" style="background:var(--p1)"></span> P1</div>
  `;

  // Seed region on timeline
  const seedPct = (m.seed_frames / m.total_frames * 100).toFixed(2);
  document.getElementById('seed-region').style.width = seedPct + '%';

  // Precompute cumulative arrays for running stats
  precomputeCumulatives();

  // Paint timeline heatmap
  paintHeatmap();

  // Stats bar (aggregate)
  renderStats();

  // Error log (teacher-forced only)
  buildErrorLog();

  renderFrame();
}

// ===== Precompute cumulative arrays =====
function precomputeCumulatives() {
  const frames = demoData.frames;
  const n = frames.length;
  cumActionCorrect = new Float32Array(n);  // running p0+p1 correct count
  cumPosError = new Float32Array(n);       // running sum of avg pos error
  frameCount = n;

  let correctCount = 0;
  let posErrSum = 0;
  let predCount = 0;

  for (let i = 0; i < n; i++) {
    const f = frames[i];
    if (f.predicted) {
      predCount++;
      if (f.predicted.p0 && f.predicted.p0.action_correct) correctCount++;
      if (f.predicted.p1 && f.predicted.p1.action_correct) correctCount++;

      const e0 = f.predicted.p0 ? f.predicted.p0.position_error : null;
      const e1 = f.predicted.p1 ? f.predicted.p1.position_error : null;
      if (e0 != null && e1 != null) posErrSum += (e0 + e1) / 2;
      else if (e0 != null) posErrSum += e0;
      else if (e1 != null) posErrSum += e1;
    }
    cumActionCorrect[i] = correctCount;
    cumPosError[i] = posErrSum;
  }
}

// ===== Timeline heatmap =====
function paintHeatmap() {
  const canvas = document.getElementById('timeline-heatmap');
  const container = document.getElementById('timeline-container');
  const rect = container.getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = 12;
  canvas.style.width = rect.width + 'px';

  const ctx = canvas.getContext('2d');
  const frames = demoData.frames;
  const n = frames.length;
  if (n === 0) return;

  const w = canvas.width;
  const isTF = demoData.meta.mode === 'teacher-forced';
  const isAgent = demoData.meta.mode === 'agent-vs-agent';

  for (let i = 0; i < n; i++) {
    const x = (i / n) * w;
    const pw = Math.max(1, w / n);
    const f = frames[i];

    let color;
    if (f.source === 'seed') {
      color = 'rgba(102, 68, 204, 0.6)';  // purple
    } else if (isTF && f.predicted) {
      // Color by position error: green < 2, orange < 5, red >= 5
      const e0 = f.predicted.p0 ? (f.predicted.p0.position_error || 0) : 0;
      const e1 = f.predicted.p1 ? (f.predicted.p1.position_error || 0) : 0;
      const err = (e0 + e1) / 2;
      if (err < 2) color = 'rgba(68, 204, 136, 0.7)';
      else if (err < 5) color = 'rgba(255, 170, 68, 0.7)';
      else color = 'rgba(255, 68, 68, 0.7)';
    } else if (isAgent && f.predicted) {
      // Color by speed anomaly or off-stage
      const p0 = f.predicted.p0 || {};
      const p1 = f.predicted.p1 || {};
      const offStage = p0.off_stage || p1.off_stage;
      const spd = Math.max(p0.speed_magnitude || 0, p1.speed_magnitude || 0);
      if (offStage) color = 'rgba(255, 170, 68, 0.7)';
      else if (spd > 3) color = 'rgba(255, 170, 68, 0.6)';
      else color = 'rgba(68, 204, 136, 0.5)';
    } else {
      color = 'rgba(136, 102, 255, 0.3)';  // autoregressive default
    }

    ctx.fillStyle = color;
    ctx.fillRect(x, 0, pw, 12);

    // KO event: bright red tick mark
    const he = f.harness_events;
    if (he && ((he.p0 && he.p0.ko) || (he.p1 && he.p1.ko))) {
      ctx.fillStyle = 'rgba(255, 40, 40, 1.0)';
      ctx.fillRect(x, 0, Math.max(2, pw), 12);
    }
  }
}

// ===== Live per-frame stats =====
function renderLiveStats(frame, idx) {
  const bar = document.getElementById('live-stats');
  const isTF = demoData.meta.mode === 'teacher-forced';
  const isAgent = demoData.meta.mode === 'agent-vs-agent';
  let chips = '';

  if (frame.source === 'seed') {
    chips = '<span class="live-chip"><span class="lc-label">Seed frame</span></span>';
    bar.innerHTML = chips;
    return;
  }

  if (isTF && frame.predicted) {
    // Action correct this frame
    const p0c = frame.predicted.p0 && frame.predicted.p0.action_correct;
    const p1c = frame.predicted.p1 && frame.predicted.p1.action_correct;
    const both = p0c && p1c;
    const cls = both ? 'good' : (p0c || p1c) ? 'warn' : 'bad';
    chips += `<span class="live-chip"><span class="lc-label">Action</span><span class="lc-val ${cls}">${both ? 'Both correct' : p0c ? 'P0 only' : p1c ? 'P1 only' : 'Both wrong'}</span></span>`;

    // Position error this frame
    const e0 = frame.predicted.p0 ? frame.predicted.p0.position_error : null;
    const e1 = frame.predicted.p1 ? frame.predicted.p1.position_error : null;
    if (e0 != null || e1 != null) {
      const avg = e0 != null && e1 != null ? ((e0 + e1) / 2) : (e0 || e1);
      const ecls = avg < 2 ? 'good' : avg < 5 ? 'warn' : 'bad';
      chips += `<span class="live-chip"><span class="lc-label">Pos err</span><span class="lc-val ${ecls}">${avg.toFixed(1)}</span></span>`;
    }

    // Running accuracy (using precomputed cumulatives)
    const seedFrames = demoData.meta.seed_frames || 0;
    const predIdx = idx - seedFrames;
    if (predIdx > 0 && cumActionCorrect) {
      const correct = cumActionCorrect[idx];
      const runAcc = (correct / (predIdx * 2) * 100).toFixed(1);
      const rcls = runAcc >= 90 ? 'good' : runAcc >= 70 ? 'warn' : 'bad';
      chips += `<span class="live-chip"><span class="lc-label">Running acc</span><span class="lc-val ${rcls}">${runAcc}%</span></span>`;
    }

    // Running pos error
    if (cumPosError && idx > seedFrames) {
      const predIdx2 = idx - seedFrames;
      const runErr = (cumPosError[idx] / predIdx2).toFixed(1);
      const ecls2 = runErr < 2 ? 'good' : runErr < 5 ? 'warn' : 'bad';
      chips += `<span class="live-chip"><span class="lc-label">Running pos err</span><span class="lc-val ${ecls2}">${runErr}</span></span>`;
    }
  }

  if (isAgent && frame.predicted) {
    const p0 = frame.predicted.p0 || {};
    const p1 = frame.predicted.p1 || {};

    // Stocks
    const s0 = p0.stocks != null ? p0.stocks : '?';
    const s1 = p1.stocks != null ? p1.stocks : '?';
    chips += `<span class="live-chip"><span class="lc-label">Stocks</span><span class="lc-val" style="color:var(--p0)">${s0}</span> <span class="lc-val" style="color:var(--p1)">${s1}</span></span>`;

    // Speed
    const spd0 = p0.speed_magnitude;
    const spd1 = p1.speed_magnitude;
    if (spd0 != null || spd1 != null) {
      const maxSpd = Math.max(spd0 || 0, spd1 || 0);
      const scls = maxSpd < 2 ? 'good' : maxSpd < 4 ? 'warn' : 'bad';
      chips += `<span class="live-chip"><span class="lc-label">Max speed</span><span class="lc-val ${scls}">${maxSpd.toFixed(1)}</span></span>`;
    }

    // Action entropy
    const ent0 = p0.action_entropy;
    const ent1 = p1.action_entropy;
    if (ent0 != null || ent1 != null) {
      const avgEnt = (ent0 != null && ent1 != null) ? ((ent0 + ent1) / 2) : (ent0 || ent1);
      const entCls = avgEnt < 1 ? 'good' : avgEnt < 3 ? 'warn' : 'bad';
      chips += `<span class="live-chip"><span class="lc-label">Entropy</span><span class="lc-val ${entCls}">${avgEnt.toFixed(2)}</span></span>`;
    }

    // Off-stage
    if (p0.off_stage || p1.off_stage) {
      const who = p0.off_stage && p1.off_stage ? 'Both' : p0.off_stage ? 'P0' : 'P1';
      chips += `<span class="live-chip"><span class="lc-label">Off-stage</span><span class="lc-val warn">${who}</span></span>`;
    }

    // Harness events
    const he = frame.harness_events;
    if (he) {
      for (const pid of ['p0', 'p1']) {
        if (he[pid] && he[pid].ko) {
          chips += `<span class="live-chip" style="border-color:var(--wrong)"><span class="lc-val bad">KO ${pid.toUpperCase()}</span></span>`;
        }
        if (he[pid] && he[pid].stock_protected) {
          chips += `<span class="live-chip"><span class="lc-label">Protected</span><span class="lc-val good">${pid.toUpperCase()}</span></span>`;
        }
      }
    }
  }

  bar.innerHTML = chips;
}

// ===== Stats =====
function renderStats() {
  const s = demoData.summary;
  const bar = document.getElementById('stats-bar');

  if (!s || s.total_frames_predicted === 0) {
    bar.innerHTML = '';
    return;
  }

  let html = '';

  if (s.p0_action_acc !== undefined) {
    const avg = ((s.p0_action_acc + s.p1_action_acc) / 2 * 100).toFixed(1);
    const cls = avg >= 90 ? 'good' : avg >= 70 ? 'warn' : 'bad';
    html += `<div class="stat-chip"><div class="label">Action Accuracy</div><div class="value ${cls}">${avg}%</div></div>`;
  }

  if (s.action_change_acc !== undefined) {
    const v = (s.action_change_acc * 100).toFixed(1);
    const cls = v >= 60 ? 'good' : v >= 40 ? 'warn' : 'bad';
    html += `<div class="stat-chip"><div class="label">Change Accuracy</div><div class="value ${cls}">${v}%</div></div>`;
  }

  if (s.avg_position_error !== undefined) {
    const cls = s.avg_position_error < 2 ? 'good' : s.avg_position_error < 5 ? 'warn' : 'bad';
    html += `<div class="stat-chip"><div class="label">Avg Pos Error</div><div class="value ${cls}">${s.avg_position_error.toFixed(1)}</div></div>`;
  }

  // Agent mode stats
  if (s.avg_speed !== undefined) {
    const cls = s.avg_speed < 1.5 ? 'good' : s.avg_speed < 3 ? 'warn' : 'bad';
    html += `<div class="stat-chip"><div class="label">Avg Speed</div><div class="value ${cls}">${s.avg_speed.toFixed(1)}</div></div>`;
  }

  if (s.ko_events !== undefined) {
    html += `<div class="stat-chip"><div class="label">KO Events</div><div class="value">${s.ko_events}</div></div>`;
  }

  if (s.stock_protections !== undefined && s.stock_protections > 0) {
    html += `<div class="stat-chip"><div class="label">Stock Saves</div><div class="value good">${s.stock_protections}</div></div>`;
  }

  if (s.final_p0_stocks !== undefined) {
    html += `<div class="stat-chip"><div class="label">Final Stocks</div><div class="value"><span style="color:var(--p0)">${s.final_p0_stocks}</span> - <span style="color:var(--p1)">${s.final_p1_stocks}</span></div></div>`;
  }

  if (s.avg_action_entropy !== undefined) {
    const cls = s.avg_action_entropy < 1 ? 'good' : s.avg_action_entropy < 3 ? 'warn' : 'bad';
    html += `<div class="stat-chip"><div class="label">Avg Entropy</div><div class="value ${cls}">${s.avg_action_entropy.toFixed(2)}</div></div>`;
  }

  html += `<div class="stat-chip"><div class="label">Frames</div><div class="value">${s.total_frames_predicted}</div></div>`;
  bar.innerHTML = html;
}

// ===== Error log (teacher-forced) =====
let errorLogData = [];  // [{frame, player, type, predicted, actual, posErr}]

function buildErrorLog() {
  errorLogData = [];
  const container = document.getElementById('error-log-container');

  if (!demoData || demoData.meta.mode !== 'teacher-forced') {
    container.style.display = 'none';
    return;
  }

  for (const f of demoData.frames) {
    if (!f.predicted || !f.actual) continue;
    for (const pid of ['p0', 'p1']) {
      const pred = f.predicted[pid];
      const act = f.actual[pid];
      if (!pred || !act) continue;

      const actionWrong = !pred.action_correct;
      const posErr = pred.position_error || 0;
      const bigPosErr = posErr >= 3;

      if (actionWrong) {
        errorLogData.push({
          frame: f.t,
          player: pid,
          type: 'action',
          predicted: pred.action_name,
          actual: act.action_name,
          posErr: posErr,
        });
      }
      if (bigPosErr && !actionWrong) {
        errorLogData.push({
          frame: f.t,
          player: pid,
          type: 'position',
          predicted: `(${pred.x.toFixed(0)}, ${pred.y.toFixed(0)})`,
          actual: `(${act.x.toFixed(0)}, ${act.y.toFixed(0)})`,
          posErr: posErr,
        });
      }
    }
  }

  container.style.display = errorLogData.length > 0 ? 'block' : 'none';
  document.getElementById('error-log-count').textContent = ` (${errorLogData.length})`;

  const tbody = document.getElementById('error-log-tbody');
  let html = '';
  for (const e of errorLogData) {
    const pCls = e.player === 'p0' ? 'p0' : 'p1';
    const typeCls = e.type === 'action' ? 'err-action-wrong' : 'err-pos';
    html += `<tr class="clickable" onclick="jumpToFrame(${e.frame})">`;
    html += `<td>${e.frame}</td>`;
    html += `<td><span class="err-player ${pCls}">${e.player.toUpperCase()}</span></td>`;
    html += `<td class="${typeCls}">${e.type}</td>`;
    html += `<td>${e.predicted}</td>`;
    html += `<td>${e.actual}</td>`;
    html += `<td>${e.posErr.toFixed(1)}</td>`;
    html += `</tr>`;
  }
  tbody.innerHTML = html;
}

function toggleErrorLog() {
  const body = document.getElementById('error-log-body');
  const chevron = document.getElementById('error-log-chevron');
  const isOpen = body.classList.toggle('open');
  chevron.innerHTML = isOpen ? '&#9650;' : '&#9660;';
}

function jumpToFrame(idx) {
  stop();
  stepTo(idx);
}

function copyErrorLog() {
  if (!errorLogData.length) return;
  let text = 'Frame\tPlayer\tType\tPredicted\tActual\tPos Error\n';
  for (const e of errorLogData) {
    text += `${e.frame}\t${e.player.toUpperCase()}\t${e.type}\t${e.predicted}\t${e.actual}\t${e.posErr.toFixed(1)}\n`;
  }
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.querySelector('#error-log-actions button');
    const orig = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = orig; }, 1500);
  });
}

// ===== Canvas rendering =====
function renderFrame() {
  if (!demoData) return;
  const frame = demoData.frames[currentFrame];
  if (!frame) return;

  drawStage(frame);
  drawPlayerCards(frame);
  renderLiveStats(frame, currentFrame);
  updateControls();
}

function drawStage(frame) {
  const canvas = document.getElementById('stage-canvas');
  const ctx = canvas.getContext('2d');
  const geo = demoData.stage_geometry;
  const cam = geo.camera_bounds || { left: -160, right: 160, top: 100, bottom: -50 };

  const W = canvas.width;
  const H = canvas.height;

  // Coordinate transform: game coords → canvas coords
  const gameW = cam.right - cam.left;
  const gameH = cam.top - cam.bottom;
  const scale = Math.min(W / gameW, H / gameH) * 1.35;
  const cx = W / 2;
  const cy = H / 2;

  function tx(gx) { return cx + (gx - (cam.left + cam.right) / 2) * scale; }
  function ty(gy) { return cy - (gy - (cam.bottom + cam.top) / 2) * scale; }

  // Clear
  ctx.fillStyle = '#0c0c18';
  ctx.fillRect(0, 0, W, H);

  // Blast zones (dashed, or red flash on KO)
  const bz = geo.blast_zones;
  const hasKO = frame.harness_events && (
    (frame.harness_events.p0 && frame.harness_events.p0.ko) ||
    (frame.harness_events.p1 && frame.harness_events.p1.ko)
  );

  if (hasKO) {
    // Red flash on KO event
    ctx.strokeStyle = 'rgba(255, 40, 40, 0.6)';
    ctx.lineWidth = 3;
    ctx.setLineDash([]);
    ctx.strokeRect(tx(bz.left), ty(bz.top), (bz.right - bz.left) * scale, (bz.top - bz.bottom) * scale);
    // Red vignette
    ctx.fillStyle = 'rgba(255, 0, 0, 0.04)';
    ctx.fillRect(0, 0, W, H);
  } else {
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    ctx.setLineDash([6, 4]);
    ctx.strokeRect(tx(bz.left), ty(bz.top), (bz.right - bz.left) * scale, (bz.top - bz.bottom) * scale);
    ctx.setLineDash([]);
  }

  // Ground
  ctx.strokeStyle = 'rgba(255,255,255,0.35)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(tx(geo.ground_x_range[0]), ty(geo.ground_y));
  ctx.lineTo(tx(geo.ground_x_range[1]), ty(geo.ground_y));
  ctx.stroke();

  // Ground edge caps
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(tx(geo.ground_x_range[0]), ty(geo.ground_y));
  ctx.lineTo(tx(geo.ground_x_range[0]), ty(geo.ground_y) + 8);
  ctx.moveTo(tx(geo.ground_x_range[1]), ty(geo.ground_y));
  ctx.lineTo(tx(geo.ground_x_range[1]), ty(geo.ground_y) + 8);
  ctx.stroke();

  // Platforms
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.lineWidth = 2;
  for (const plat of geo.platforms || []) {
    ctx.beginPath();
    ctx.moveTo(tx(plat.x_range[0]), ty(plat.y));
    ctx.lineTo(tx(plat.x_range[1]), ty(plat.y));
    ctx.stroke();
  }

  const isTF = demoData.meta.mode === 'teacher-forced';
  const isSeed = frame.source === 'seed';

  // Draw players
  const r = 10; // player radius
  const colors = { p0: '#4488ff', p1: '#ff4466' };

  for (const pid of ['p0', 'p1']) {
    const color = colors[pid];

    if (isSeed || !isTF) {
      // Single dot: actual (seed) or predicted (autoregressive)
      const data = isSeed ? frame.actual[pid] : (frame.predicted ? frame.predicted[pid] : frame.actual[pid]);
      if (!data) continue;
      const px = tx(data.x);
      const py = ty(data.y);

      // Facing indicator
      const dir = data.facing_right ? 1 : -1;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(px + dir * 14, py);
      ctx.stroke();
      ctx.globalAlpha = 1;

      // Player dot
      ctx.fillStyle = color;
      ctx.globalAlpha = isSeed ? 0.5 : 1;
      ctx.beginPath();
      ctx.arc(px, py, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // Percent label
      ctx.fillStyle = color;
      ctx.font = '11px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`${Math.round(data.percent)}%`, px, py - r - 6);

      // Stock dots
      for (let s = 0; s < data.stocks; s++) {
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.arc(px - 8 + s * 6, py + r + 8, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

    } else if (isTF && frame.predicted) {
      // Teacher-forced: both actual (solid) and predicted (translucent)
      const actual = frame.actual[pid];
      const pred = frame.predicted[pid];

      const ax = tx(actual.x);
      const ay = ty(actual.y);
      const ppx = tx(pred.x);
      const ppy = ty(pred.y);

      // Error line
      const dist = Math.sqrt((actual.x - pred.x) ** 2 + (actual.y - pred.y) ** 2);
      if (dist > 0.5) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.25;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(ppx, ppy);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
      }

      // Predicted (translucent, behind)
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.25;
      ctx.beginPath();
      ctx.arc(ppx, ppy, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // Actual (solid)
      const adir = actual.facing_right ? 1 : -1;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.moveTo(ax, ay);
      ctx.lineTo(ax + adir * 14, ay);
      ctx.stroke();
      ctx.globalAlpha = 1;

      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(ax, ay, r, 0, Math.PI * 2);
      ctx.fill();

      // Percent label
      ctx.fillStyle = color;
      ctx.font = '11px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`${Math.round(actual.percent)}%`, ax, ay - r - 6);

      // Stock dots
      for (let s = 0; s < actual.stocks; s++) {
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.arc(ax - 8 + s * 6, ay + r + 8, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }
  }

  // Frame source label
  ctx.fillStyle = frame.source === 'seed' ? 'rgba(102,68,204,0.6)' : 'rgba(136,102,255,0.4)';
  ctx.font = '10px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(frame.source.toUpperCase(), 12, 18);
}

// ===== Player cards =====
function drawPlayerCards(frame) {
  for (const pid of ['p0', 'p1']) {
    const card = document.getElementById(`${pid}-card`);
    const actual = frame.actual ? frame.actual[pid] : null;
    const pred = frame.predicted ? frame.predicted[pid] : null;
    const isTF = demoData.meta.mode === 'teacher-forced';
    const charName = demoData.meta.characters[pid].name;

    let html = `<h3>${pid === 'p0' ? 'Player 1' : 'Player 2'} — ${charName}</h3>`;

    if (frame.source === 'seed' && actual) {
      html += `<div class="action-line">${actual.action_name}</div>`;
      html += `<div class="stats-line">${actual.percent.toFixed(0)}% &middot; ${actual.stocks} stocks &middot; (${actual.x.toFixed(0)}, ${actual.y.toFixed(0)})</div>`;
    } else if (isTF && actual && pred) {
      const correct = pred.action_correct;
      const icon = correct ? '&#10003;' : '&#10007;';
      const cls = correct ? 'action-correct' : 'action-wrong';

      if (actual.action_name === pred.action_name) {
        html += `<div class="action-line"><span class="${cls}">${icon}</span> ${actual.action_name}</div>`;
      } else {
        html += `<div class="action-line"><span class="${cls}">${icon}</span> ${actual.action_name} <span style="color:var(--text-dim)">&rarr;</span> ${pred.action_name}</div>`;
      }

      html += `<div class="stats-line">${actual.percent.toFixed(0)}% &middot; ${actual.stocks} stocks &middot; err ${pred.position_error !== undefined ? pred.position_error.toFixed(1) : '?'}</div>`;

      // Top 3 actions
      if (pred.top3_actions) {
        html += '<div class="top3">';
        for (const a of pred.top3_actions) {
          const barW = Math.max(1, a.prob * 80);
          html += `<div><span class="prob-bar" style="width:${barW}px"></span>${a.name} ${(a.prob * 100).toFixed(1)}%</div>`;
        }
        html += '</div>';
      }
    } else if (pred) {
      // Autoregressive
      html += `<div class="action-line">${pred.action_name}</div>`;
      html += `<div class="stats-line">${pred.percent.toFixed(0)}% &middot; ${pred.stocks} stocks &middot; (${pred.x.toFixed(0)}, ${pred.y.toFixed(0)})</div>`;

      if (pred.top3_actions) {
        html += '<div class="top3">';
        for (const a of pred.top3_actions) {
          const barW = Math.max(1, a.prob * 80);
          html += `<div><span class="prob-bar" style="width:${barW}px"></span>${a.name} ${(a.prob * 100).toFixed(1)}%</div>`;
        }
        html += '</div>';
      }
    }

    card.innerHTML = html;
  }
}

// ===== Controls =====
function updateControls() {
  const total = demoData.frames.length;
  document.getElementById('frame-display').textContent = `Frame ${currentFrame}/${total - 1}`;

  const pct = total > 1 ? (currentFrame / (total - 1) * 100) : 0;
  document.getElementById('timeline-progress').style.width = pct + '%';
  document.getElementById('timeline-thumb').style.left = pct + '%';
}

function stop() {
  playing = false;
  if (playInterval) { clearInterval(playInterval); playInterval = null; }
  document.getElementById('btn-play').classList.remove('active');
  document.getElementById('btn-play').innerHTML = '&#9654;';
}

function play() {
  if (playing) { stop(); return; }
  playing = true;
  document.getElementById('btn-play').classList.add('active');
  document.getElementById('btn-play').innerHTML = '&#9646;&#9646;';

  const fps = 60;
  const interval = 1000 / (fps * speed);
  playInterval = setInterval(() => {
    if (currentFrame >= demoData.frames.length - 1) { stop(); return; }
    currentFrame++;
    renderFrame();
  }, interval);
}

function stepTo(frame) {
  const total = demoData.frames.length;
  currentFrame = Math.max(0, Math.min(total - 1, frame));
  renderFrame();
}

// Button handlers
document.getElementById('btn-play').addEventListener('click', play);
document.getElementById('btn-back').addEventListener('click', () => { stop(); stepTo(currentFrame - 1); });
document.getElementById('btn-fwd').addEventListener('click', () => { stop(); stepTo(currentFrame + 1); });
document.getElementById('btn-rew').addEventListener('click', () => { stop(); stepTo(currentFrame - 10); });
document.getElementById('btn-ffwd').addEventListener('click', () => { stop(); stepTo(currentFrame + 10); });

document.getElementById('speed-select').addEventListener('change', e => {
  speed = parseFloat(e.target.value);
  if (playing) { stop(); play(); }
});

// Timeline click/drag
const timelineContainer = document.getElementById('timeline-container');
let draggingTimeline = false;

function setFrameFromMouse(e) {
  const rect = timelineContainer.getBoundingClientRect();
  const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
  stepTo(Math.round(pct * (demoData.frames.length - 1)));
}

timelineContainer.addEventListener('mousedown', e => { draggingTimeline = true; stop(); setFrameFromMouse(e); });
document.addEventListener('mousemove', e => { if (draggingTimeline) setFrameFromMouse(e); });
document.addEventListener('mouseup', () => { draggingTimeline = false; });

// Keyboard
document.addEventListener('keydown', e => {
  if (!demoData) return;
  switch (e.code) {
    case 'Space': e.preventDefault(); play(); break;
    case 'ArrowRight':
      e.preventDefault();
      stop();
      stepTo(currentFrame + (e.shiftKey ? 10 : 1));
      break;
    case 'ArrowLeft':
      e.preventDefault();
      stop();
      stepTo(currentFrame - (e.shiftKey ? 10 : 1));
      break;
    case 'Home': e.preventDefault(); stop(); stepTo(0); break;
    case 'End': e.preventDefault(); stop(); stepTo(demoData.frames.length - 1); break;
  }
});
</script>

</body>
</html>
